*DECK INTDCM
C
C
C
      FUNCTION INTDCM(CLIST1,CLIST2,STRING,ILIST)
C
C THIS ROUTINE COMPARES THE CHARACTERS IN 'STRING' AGAINST THE TWO LISTS
C CLIST1 AND CLIST2 AND RETURNS THE POSITION IN THE LIST WHICH AGREES
C WITH STRING UP TO AS MANY CHARACTERS AS ARE CONTAINED IN STRING.  IF
C NO MATCH CAN BE FOUND THEN INTDCM IS ZERO ON EXIT.  IF MORE THAN ONE
C MATCH IS FOUND THEN THE FOLLOWING ACTION IS TAKEN: IF THE VALUE IN
C CLISTn IS ALSO AMBIGOUS THEN THE STRING IS ASSUMED AS MATCHING THE
C SHORTEST OF THE MATCHING CLISTn ENTRIES; OTHERWISE IF THE VALUE IN
C CLISTn IS NOT AMBIGUOUS OR IF THE AMBIGUOUS ENTRIES ARE IDENTICAL THEN
C INTDCM IS SET THE NEGATIVE OF THE FIRST ENTRY.
C INPUT ARGUMENTS:
C  CLIST    - THE LIST OF STRINGS TO COMPARE 'STRING' AGAINST TERMINATED
C             WITH A BLANK ENTRY.
C  STRING   - THE STRING TO COMPARE.
C OUTPUT ARGUMENTS:
C  ILIST    - THE COMMAND LIST CONTAINING THE MATCH (CLIST1 = 1,
C             CLIST2 = 2).
C  INTDCM   - THE POSITION OF THE MATCHING STRING IN CLIST, 0 IF NO
C             MATCH IS FOUND, -VE IF THE MATCH IS AMBIGUOUS (SEE ABOVE).
C     VERSION 1.0   14MAY85
C
      CHARACTER*(*) CLIST1(*),CLIST2(*),STRING*(*)
      LOGICAL COMSTR
C
C SET INTDCM.
C
      INTDCM=0
C
C SCAN THROUGH CLIST1 COMPARING THE ENTRIES WITH STRING UNTIL THE END OF
C THE LIST IS REACHED.
C
      I=1
      ILIST=0
 1000 IF(CLIST1(I).NE.' ') THEN
C
C COMPARE THE ENTRY AGAINST STRING.
C
        IF(COMSTR(CLIST1(I),STRING)) THEN
C
C THEY AGREE, TEST IF A PREVIOUS ENTRY ALSO AGREED.
C
          IF(INTDCM.NE.0) THEN
C
C YES, ARE BUT ARE THE ENTRIES IN CLIST1 AMBIGUOUS?  FIRST CHECK IF THEY
C ARE IDENTICAL.
C
            L1=LENGTH(CLIST1(ABS(INTDCM)))
            L2=LENGTH(CLIST1(I))
            IF(CLIST1(ABS(INTDCM)).EQ.CLIST1(I)) THEN
C
C THEY ARE IDENTICAL, NOTE THE POSSIBLE AMBIGUITY.
C
              INTDCM=-ABS(INTDCM)
            ELSEIF(L1.LT.L2) THEN
C
C THE PREVIOUS MATCH IS THE SHORTEST, ARE THE ENTRIES AMBIGUOUS?
C
              IF(COMSTR(CLIST1(I),CLIST1(ABS(INTDCM)))) THEN
C
C YES, STAY WITH THE PREVIOUS MATCH.
C
                INTDCM=ABS(INTDCM)
              ELSE
C
C NO, THE STRING IS AMBIGUOUS: EXIT.
C
                INTDCM=-ABS(INTDCM)
                GOTO 7777
              ENDIF
            ELSE
C
C THE PREVIOUS MATCH IS THE LONGER STRING OF THE TWO, ARE THE ENTRIES
C IN CLIST1 AMBIGUOUS?
C
              IF(COMSTR(CLIST1(ABS(INTDCM)),CLIST1(I))) THEN
C
C YES, USE THE MATCH TO THE LATEST ENTRY.
C
                INTDCM=I
              ELSE
C
C NO, THE STRING IS AMBIGUOUS: EXIT.
C
                INTDCM=-ABS(INTDCM)
                GOTO 7777
              ENDIF
            ENDIF
          ELSE
C
C THERE ARE NO PREVIOUS MATCHES, SET INTDCM TO THE LIST ENTRY NUMBER.
C
            INTDCM=I
            ILIST=1
          ENDIF
        ENDIF
C
C GET THE NEXT ENTRY.
C
        I=I+1
        GOTO 1000
      ENDIF
C
C NOW SEARCH CLIST2 IN THE SAME WAY.
C
      I=1
 2000 IF(CLIST2(I).NE.' ') THEN
C
C COMPARE THE ENTRY AGAINST STRING.
C
        IF(COMSTR(CLIST2(I),STRING)) THEN
C
C THEY AGREE, TEST IF A PREVIOUS ENTRY ALSO AGREED.
C
          IF(INTDCM.NE.0) THEN
C
C YES, ARE BUT ARE THE ENTRIES IN CLIST AMBIGUOUS?  FIRST CHECK IF THEY
C ARE IDENTICAL.  FIRST TEST WHICH LIST THE FIRST ENTRY WAS IN.
C
            IF(ILIST.EQ.1) THEN
C
C FIRST LIST.
C
              L1=LENGTH(CLIST1(ABS(INTDCM)))
              L2=LENGTH(CLIST2(I))
              IF(CLIST1(ABS(INTDCM)).EQ.CLIST2(I)) THEN
C
C THEY ARE IDENTICAL, NOTE THE POSSIBLE AMBIGUITY.
C
                INTDCM=-ABS(INTDCM)
              ELSEIF(L1.LT.L2) THEN
C
C THE PREVIOUS MATCH IS THE SHORTEST, ARE THE ENTRIES AMBIGUOUS?
C
                IF(COMSTR(CLIST2(I),CLIST1(ABS(INTDCM)))) THEN
C
C YES, STAY WITH THE PREVIOUS MATCH.
C
                  INTDCM=ABS(INTDCM)
                ELSE
C
C NO, THE STRING IS AMBIGUOUS: EXIT.
C
                  INTDCM=-ABS(INTDCM)
                  GOTO 7777
                ENDIF
              ELSE
C
C THE PREVIOUS MATCH IS THE LONGER STRING OF THE TWO, ARE THE ENTRIES
C IN CLIST AMBIGUOUS?
C
                IF(COMSTR(CLIST1(ABS(INTDCM)),CLIST2(I))) THEN
C
C YES, USE THE MATCH TO THE LATEST ENTRY.
C
                  INTDCM=I
                  ILIST=2
                ELSE
C
C NO, THE STRING IS AMBIGUOUS: EXIT.
C
                  INTDCM=-ABS(INTDCM)
                  GOTO 7777
                ENDIF
              ENDIF
            ELSE
C
C SECOND LIST.
C
              L1=LENGTH(CLIST2(ABS(INTDCM)))
              L2=LENGTH(CLIST2(I))
              IF(CLIST2(ABS(INTDCM)).EQ.CLIST2(I)) THEN
C
C THEY ARE IDENTICAL, NOTE THE POSSIBLE AMBIGUITY.
C
                INTDCM=-ABS(INTDCM)
              ELSEIF(L1.LT.L2) THEN
C
C THE PREVIOUS MATCH IS THE SHORTEST, ARE THE ENTRIES AMBIGUOUS?
C
                IF(COMSTR(CLIST2(I),CLIST2(ABS(INTDCM)))) THEN
C
C YES, STAY WITH THE PREVIOUS MATCH.
C
                  INTDCM=ABS(INTDCM)
                ELSE
C
C NO, THE STRING IS AMBIGUOUS: EXIT.
C
                  INTDCM=-ABS(INTDCM)
                  GOTO 7777
                ENDIF
              ELSE
C
C THE PREVIOUS MATCH IS THE LONGER STRING OF THE TWO, ARE THE ENTRIES
C IN CLIST2 AMBIGUOUS?
C
                IF(COMSTR(CLIST2(ABS(INTDCM)),CLIST2(I))) THEN
C
C YES, USE THE MATCH TO THE LATEST ENTRY.
C
                  INTDCM=I
                ELSE
C
C NO, THE STRING IS AMBIGUOUS: EXIT.
C
                  INTDCM=-ABS(INTDCM)
                  GOTO 7777
                ENDIF
              ENDIF
            ENDIF
          ELSE
C
C THERE ARE NO PREVIOUS MATCHES, SET INTDCM TO THE LIST ENTRY NUMBER.
C
            INTDCM=I
            ILIST=2
          ENDIF
        ENDIF
C
C GET THE NEXT ENTRY.
C
        I=I+1
        GOTO 2000
      ENDIF
C
C THE END OF THE LIST HAS BEEN REACHED, EXIT.
C
 7777 RETURN
C
C END OF INTEGER FUNCTION INTDCM.
C
      END
