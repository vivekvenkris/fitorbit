*DECK PSRCMD
C
C **************************************************************
      SUBROUTINE PSRCMD ( PROGID,
     &     CMDLST, MAXCMD, CMDDSC, MAXDSC, ICMDGRP, ICMD,
     &     CMDINP, JINP, NINP, MAXINP, 
     &     PARLST, PARDSC, PARID, MAXPAR, IPARGRP,
     &     IPAR, RPAR, DPAR, LPAR, CPAR,
     &     IIUNITS, IRUNITS, IDUNITS, IFAIL )
C **************************************************************
C
C THE PULSAR COMMAND INTERPRETER.
C PROGID CONTAINS THE PROGRAM NAME.
C CMDLST CONTAINS THE LISTS OF COMMANDS WITH UP TO MAXCMD COMMANDS
C     IN EACH LIST. CMDLST(*,0) IS THE PRIMARY COMMAND LIST AND
C     CMDLST(*,I) IS THE LIST OF SUBSIDIARY COMMANDS FOR PRIMARY
C     COMMAND I.
C CMDDSC CONTAINS THE COMMAND DESCRIPTIONS WITH TWO DESCRIPTION
C     LINES FOR EACH COMMAND.
C ICMDGRP AND ICMD RETURN THE COMMAND GROUP AND COMMAND NUMBER THAT
C     HAVE BEEN REQUESTED BY THE USER.
C CMDINP RETURNS THE ACTUAL COMMANDS GIVEN BY THE USER, WHERE NINP
C     ARE THEIR NUMBER AND JINP POINTS TO THE NEXT COMMAND TO BE
C     INTERPRETED. MAXINP IS THE MAXIMUM NUMBER OF INPUT COMMANDS
C     ALLOWED.
C PARLST CONTAINS THE LIST OF PARAMETERS AND PARDSC THEIR DESCRIPTIONS,
C     WITH TWO DESCRIPTION LINES PER PARAMETER.
C PARID CONTAINS THE LISTS OF PARAMETER IDENTIFIERS AS REQUIRED BY THE
C     PARAMETER HANDLING ROUTINES AND MAXPAR IS THE MAXIMUM NUMBER OF
C     PARAMETERS. THERE MUST BE A PARAMETER IDENTIFIER FOR EACH 
C     PARAMETER IN THE LIST.
C IPARGRP CONTAINS THE NUMBER OF THE PARAMETER IDENTIFIER LIST WHICH IS
C     TO BE USED FOR EACH PRIMARY COMMAND, ENABLING THE PARAMETER LIST
C     TO BE CHANGED FOR DIFFERENT COMMANDS. THERE MUST BE AS MANY
C     ENTRIES IN IPARGRP AS THERE ARE PRIMARY COMMANDS, ALTHOUGH AN
C     ENTRY MAY BE ZERO INDICATING THAT NO PARAMETERS MAY BE ACCESSED
C     FROM THAT COMMAND.
C IPAR,RPAR,LPAR,DPAR,CPAR,IIUNITS,IRUNITS,IDUNITS
C     ARE THE PARAMETERS AND THEIR UNITS. THEIR USE IS DESCRIBED IN THE
C     PARAMETER HANDLING ROUTINES.
C IFAIL SHOULD BE ZERO IF COMMAND PROCESSING WAS SUCCESSFUL IN THE
C     CALLING PROGRAM, OTHERWISE IT SHOULD CONTAIN THE ERROR NUMBER.
C 
c MOD 10/03/2006 correct data types in calls to psrerr
c
      INTEGER IFIRST
      CHARACTER*(*) PROGID,CMDLST(MAXCMD,0:*),CMDDSC(MAXDSC,0:*)
     &   ,CMDINP(*),PARLST(*),PARDSC(*),CPAR(*),PARID(MAXPAR,0:*)
      INTEGER IPARGRP(0:*),IPAR(*),IIUNITS(*),IRUNITS(*),IDUNITS(*)
     &    ,ncmdgrp
      REAL RPAR(*)
      DOUBLE PRECISION DPAR(*)
      LOGICAL LPAR(*),COMSTR
C
      CHARACTER IDENT*81,PROMPT*20,CPRMPT*1,OPSCLI*10,OUTBUF*81
      CHARACTER*10 GBLLST(7)
      CHARACTER*60 GBLDSC(14)
C
      DATA CPRMPT / '>' /
      DATA GBLLST
     &   / 'show','set','scan','graphics','exit','dcl',' ' /
      DATA GBLDSC
     &   / 'Display something',' '
     &    ,'Change one of the parameters',' '
     &    ,'Scan through the parameters',' '
     &    ,'Access the graphics commands',' '
     &    ,'Exit the current command level',' '
     &    ,'Obey simple DCL commands',' ',' ',' ' /
      PARAMETER ( IEXCMD=5,IOPSCMD=6 )
      DATA NCMDGRP/0/ 
      save
C
C     FIRST TIME, SET THE HELP DIRECTORY AND ERROR HANDLING STATUSES.
C

      IF (IFIRST.EQ.0) THEN
        IFIRST = 1
        CALL SETHLP ('PSRHELPDIR')
        CALL SETLER (0,1)
        CALL SETLER (1,2)
        CALL SETPER (0,2)
        CALL SETPER (1,2)
      ENDIF
C
C     SET THE COMMAND NAME AND DESCRIPTION FOR PASSING
C     COMMANDS TO THE OPERATING SYSTEM.
C
      GBLLST(IOPSCMD) = OPSCLI()
      IF ( GBLLST(IOPSCMD).NE.' ' ) THEN
         GBLDSC(2*IOPSCMD-1) = 'Enter '
     &      //GBLLST(IOPSCMD)(1:LENGTH(GBLLST(IOPSCMD)))//' command'
      ENDIF
C
C     LABEL 10 IS THE RETURN POINT FOR SUCCESSFUL COMPLETION OF A
C     COMMAND OR IN CASE OF AN ERROR.
C
   10 CONTINUE
C
C     IF THE COMMAND PROCESSING WAS SUCCESSFUL AND THERE ARE UNUSED
C     COMMAND PARAMETERS, INFORM OF THE PARAMETERS WHICH ARE IGNORED.
C
      IF ( IFAIL.EQ.0.AND.JINP.LE.NINP.AND.NINP.GT.0 ) THEN
         ICMDGRP = 0
         GOTO 20
      ENDIF
C
C     SET THE CURRENT COMMAND GROUP TO THE NEXT COMMAND GROUP.
C
      ICMDGRP = NCMDGRP
C
C     CLEAR THE COMMAND INPUT ARRAY.
C
      NINP = 0
      JINP = 1
C
C     LABEL 20 IS THE RETURN POINT WHEN A COMMAND IS PARTIALLY PROCESSED
C     BUT REQUIRES FURTHER COMMANDS.
C
   20 CONTINUE
C
C     SET THE IDENTIFIER FOR USE WITH THE HELP COMMAND
C     AND SET THE CURRENT COMMAND PROMPT.
C
      IF ( PROGID.EQ.'SETEDIT' ) THEN
         IDENT = 'SETEDIT'
         PROMPT = 'SETEDIT'//CPRMPT
      ELSEIF ( ICMDGRP.EQ.0 ) THEN
         IDENT = PROGID
         PROMPT = CPRMPT
      ELSE
         IDENT = PROGID(1:MAX(1,LENGTH(PROGID)))//' '
     &            //CMDLST(ICMDGRP,0)
         PROMPT = CMDLST(ICMDGRP,0)(1:LENGTH(CMDLST(ICMDGRP,0)))
     &            //CPRMPT
      ENDIF
C
C     SUPPRESS CERTAIN ERRORS SO THAT A FAULTY GLOBAL COMMAND
C     MAY BE INTERPRETED AS A LOCAL COMMAND.
C
      CALL SETLER (5,2)
      CALL SETLER (26,2)
      CALL SETLER (23,2)
      CALL SETPER (5,1)
      CALL SETPER (23,1)

C
C     TEST WHETHER MORE PARAMETERS ARE REQUIRED FROM THE USER.
C
      IF ( JINP.GT.NINP ) THEN
C
C        GET A COMMAND CHECKING AGAINST THE GLOBAL COMMANDS.
C
         IF (PROGID.EQ.'EDIT') THEN
            CALL GETEDT
     &        ( GBLLST,PROMPT,CMDINP,MAXINP,NINP,ICMD,PROGID,IFAIL )
         ELSE
            CALL GETCMD
     &        ( GBLLST,PROMPT,CMDINP,MAXINP,NINP,ICMD,PROGID,IFAIL )
         ENDIF
C
C        SET THE INPUT COMMAND POINTER.
C
         JINP = 1
      ELSE
C
C        THERE ARE STILL COMMANDS IN THE INPUT COMMAND LIST.
C        CHECK THE CURRENT COMMAND AGAINST THE GLOBAL LIST.
C
         ICMD = INTCMD ( GBLLST,CMDINP(JINP) )
         IF ( ICMD.EQ.0 ) THEN
            IFAIL = 5
            CALL PSRERR ('PSRCMD',IFAIL,0,0.,CMDINP(JINP))
         ELSEIF ( ICMD.LT.0 ) THEN
            IFAIL = 6
            CALL PSRERR ('PSRCMD',IFAIL,0,0.,CMDINP(JINP))
         ENDIF
      ENDIF
C
C     END-OF-FILE ( ERROR 1 ) IS EQUIVALENT TO 'EXIT'.
C
      IF ( IFAIL.EQ.1 ) THEN
         ICMD = IEXCMD
         IFAIL = 0
      ENDIF
C
C     IF THERE WAS AN ERROR OTHER THAN UNRECOGNIZED COMMAND,
C     RETURN FOR ANOTHER COMMAND.
C
      IF ( IFAIL.NE.0.AND.IFAIL.NE.5 ) THEN
         GOTO 10
      ENDIF
C
C     IF THE COMMAND WAS RECOGNIZED, INCREMENT THE COMMAND POINTER,
C     OTHERWISE ENSURE THAT NO GLOBAL COMMAND IS EXECUTED.
C
      IF ( IFAIL.NE.5 ) THEN
         JINP = JINP+1
      ELSE
         ICMD = 0
      ENDIF
C
C     THE COMMAND IS DECODED - TEST FOR EACH OF THE GLOBAL COMMANDS.
C
C 'SHOW' COMMAND -------------------------------------------------------
C
      IF ( ICMD.EQ.1 ) THEN
C
C        IF THERE IS NO PARAMETER LIST,
C        SUPPLY SHWCMD WITH AN EMPTY LIST.
C
         IF ( IPARGRP(ICMDGRP).EQ.0 ) THEN
            CALL SHWCMD ( CMDINP,NINP,JINP,PROGID
     &         ,GBLLST,GBLDSC,CMDLST(1,ICMDGRP),CMDDSC(1,ICMDGRP)
     &         ,' ',' ',' '
     &         ,IPAR,RPAR,DPAR,LPAR,CPAR
     &         ,IIUNITS,IRUNITS,IDUNITS,IFAIL )
         ELSE
            CALL SHWCMD ( CMDINP,NINP,JINP,PROGID
     &         ,GBLLST,GBLDSC,CMDLST(1,ICMDGRP),CMDDSC(1,ICMDGRP)
     &         ,PARLST,PARDSC,PARID(1,IPARGRP(ICMDGRP))
     &         ,IPAR,RPAR,DPAR,LPAR,CPAR
     &         ,IIUNITS,IRUNITS,IDUNITS,IFAIL )
         ENDIF
C
C 'SET' COMMAND --------------------------------------------------------
C
      ELSEIF ( ICMD.EQ.2 ) THEN
C
C        CHECK THAT THERE IS A PARAMETER LIST.
C
         IF ( IPARGRP(ICMDGRP).GT.0 ) THEN
            CALL SETCMD ( CMDINP,NINP,JINP
     &         ,PARLST,PARDSC,PARID(1,IPARGRP(ICMDGRP))
     &         ,IPAR,RPAR,DPAR,LPAR,CPAR
     &         ,IIUNITS,IRUNITS,IDUNITS,IFAIL )
         ELSE
            IFAIL = 42
            CALL PSRERR ('PSRCMD',IFAIL,0,0.0,' ')
         ENDIF
C
C 'SCAN' COMMAND -------------------------------------------------------
C
      ELSEIF ( ICMD.EQ.3 ) THEN
C
C        CHECK THAT THERE IS A PARAMETER LIST.
C
         IF ( IPARGRP(ICMDGRP).GT.0 ) THEN
C
C           PERFORM THE SCAN.
C
            CALL SCNPAR ( CMDINP,NINP,JINP
     &              ,IDENT,PARLST,PARDSC,PARID(1,IPARGRP(ICMDGRP))
     &              ,IPAR,RPAR,DPAR,LPAR,CPAR,IIUNITS,IRUNITS,
     &               IDUNITS, IFAIL )
         ELSE
            IFAIL = 42
            CALL PSRERR ('PSRCMD',IFAIL,0,0.0,' ')
         ENDIF
C
C 'GRAPHICS' COMMAND ---------------------------------------------------
C
      ELSEIF ( ICMD.EQ.4 ) THEN
              CALL GRPCMD ( CMDINP,NINP,JINP
     &              ,PARLST,PARDSC,PARID(1,0)
     &              ,IPAR,RPAR,DPAR,LPAR,CPAR
     &              ,IIUNITS,IRUNITS,IDUNITS,IFAIL )
C
C 'EXIT' COMMAND -------------------------------------------------------
C
      ELSEIF ( ICMD.EQ.5 ) THEN
         IF ( ICMDGRP.GT.0 ) THEN
            NCMDGRP = 0
         ELSE
            ICMDGRP = -1
         ENDIF
C
C PASS COMMANDS TO OPERATING SYSTEM ------------------------------------
C
      ELSEIF ( ICMD.EQ.6 ) THEN
         CALL OPSCMD (CMDINP,JINP,NINP)
      ENDIF
C
C     RESTORE STATUS OF ERRORS.
C
      CALL SETLER (5,1)
      CALL SETLER (26,1)
      CALL SETLER (23,1)
      CALL SETPER (5,2)
      CALL SETPER (23,2)

C
C     IF THE COMMAND IS STILL NOT RECOGNIZED,
C     CHECK IT AGAINST THE LOCAL COMMAND LIST.
C
      IF ( IFAIL.EQ.5.OR.IFAIL.EQ.23 ) THEN
C
C        IF IT WAS RECOGNIZED AS A GLOBAL COMMAND, BUT FOUND SOMETHING
C        SUBSEQUENTLY UNRECOGNIZABLE, THEN STEP BACK ONE COMMAND.
C
         IF ( ICMD.GT.0 ) THEN
            JINP = JINP-1
         ENDIF
C
C        CLEAR THE ERROR FLAG, SAVING THE ORIGINAL ERROR,
C        AND SEARCH THE LOCAL COMMAND LIST.
C
         IFAIL1 = IFAIL
         IFAIL = 0
         ICMD = INTCMD( CMDLST(1,ICMDGRP),CMDINP(JINP) )
C
C        CHECK WHETHER FOUND IN LOCAL LIST.
C
         IF ( ICMD.LE.0 ) THEN
            IF ( ICMD.EQ.0 ) THEN
C
C              THE COMMAND IS STILL NOT RECOGNIZED.
C              IF THE ORIGINAL FAILURE WAS 'COMMAND NOT RECOGNIZED',
C              ASSUME THAT 'SHOW' WAS INTENDED.
C
               IF ( IFAIL1.EQ.5 ) THEN
                  IF ( IPARGRP(ICMDGRP).EQ.0 ) THEN
                     CALL SHWCMD ( CMDINP,NINP,JINP,PROGID
     &               ,GBLLST,GBLDSC,CMDLST(1,ICMDGRP),CMDDSC(1,ICMDGRP)
     &               ,' ',' ',' '
     &               ,IPAR,RPAR,DPAR,LPAR,CPAR
     &               ,IIUNITS,IRUNITS,IDUNITS,IFAIL )
                  ELSE
                     CALL SHWCMD ( CMDINP,NINP,JINP,PROGID
     &               ,GBLLST,GBLDSC,CMDLST(1,ICMDGRP),CMDDSC(1,ICMDGRP)
     &               ,PARLST,PARDSC,PARID(1,IPARGRP(ICMDGRP))
     &               ,IPAR,RPAR,DPAR,LPAR,CPAR
     &               ,IIUNITS,IRUNITS,IDUNITS,IFAIL )
                  ENDIF
               ELSE
C
C                 GIVE THE BELATED ERROR MESSAGE.
C
                  IFAIL = IFAIL1
                  CALL PSRERR ('PSRCMD',IFAIL,0,0.0,' ')
               ENDIF
            ELSE
               IFAIL = 6
               CALL PSRERR ('PSRCMD',IFAIL,0,0.0,CMDINP(JINP))
            ENDIF
            GOTO 10
         ENDIF
         JINP = JINP+1
      ELSEIF ( ICMDGRP.GE.0.AND.ICMD.GT.0 ) THEN
C
C        SUCCESSFUL COMPLETION OF GLOBAL COMMAND ( OTHER THAN 'EXIT' )
C        RETURN FOR ANOTHER COMMAND.
C
         GOTO 10
      ENDIF
C
C     FOR THE PRIMARY COMMAND GROUP ( ICMDGRP=0 ),
C     SET THE NEXT COMMAND GROUP.
C
      IF ( ICMDGRP.EQ.0 ) THEN
C
C        DEFAULT NEXT COMMAND GROUP IS 0.
C        SET CURRENT COMMAND GROUP TO ICMD.
C
         NCMDGRP = 0
         ICMDGRP=ICMD
C
C        CHECK WHETHER A SECOND PARAMETER IS REQUIRED.
C
         IF ( CMDLST(1,ICMDGRP).NE.' ' ) THEN
C
C           IF THERE WAS ONLY ONE COMMAND PARAMETER,
C           SET NEXT GROUP TO ICMD AND EXIT WITH ICMD SET TO ZERO.
C
            IF ( NINP.EQ.1 ) THEN
               NCMDGRP = ICMD
               ICMD = 0
            ELSE
C
C              OTHERWISE GO BACK TO THE COMMAND INTERPRETER FOR THE
C              SECOND PARAMETER
C
               GOTO 20
            ENDIF
         ENDIF
      ENDIF
C
      RETURN
C
C END OF SUBROUTINE PSRCMD
C
      END
