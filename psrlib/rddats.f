*DECK RDDATS
C
C *************************************************************
      SUBROUTINE RDDATS ( IFAIL )
C *************************************************************
C
C READS DATA FROM THE WORKING SPACE ASSUMING THAT IT CONTAINS
C     A HEADER FOLLOWED BY DATA FROM A PREVIOUS CALL OF RDHEAD
C     GIVING ONE SHORT ELEMENT OF THE INPUT ARRAY FOR EACH DATA BIN.
C CALL RDASPDATS IF READING ASPDATA.
C THE FIRST DATA BIN IS LOADED INTO THE ELEMENT POINTED TO BY INWR
C     AND INWR IS UPDATED AT THE END OF THE READ
C IFAIL=0 IF NO ERROR HAS OCCURRED.
C
C THIS ROUTINE IS INSTALLATION DEPENDENT.
C
C VAX-11 FORTRAN VERSION.
C
c Mod 10/03/2006 Correct data type in call to pserr
c
      INCLUDE 'PSRLIBDIR:PSRLIB.DEF'
      INCLUDE 'PSRLIBDIR:PSRDAT.DEF'
      BYTE INB(MAXIN*4)
      EQUIVALENCE (IN,INB)
      PARAMETER (LENIND=MAXWORK-39)
      INTEGER INDAT(LENIND)
      EQUIVALENCE (WRK(39),INDAT)
C
      IFAIL = 0
C
C     CHECK IF WE ARE DEALING WITH ASPDATA
C
      IF (LASPDAT) THEN
        CALL RDASPDATS(IFAIL)
        RETURN
      ENDIF
C
      IF ( NCH.GT.MAXCHAN ) THEN
         CALL OUTMON (
     &   ' ***** No. of input data channels exceeds array space' )
         CALL OUTMON ( '       Number of channels truncated' )
         NCH = MAXCHAN
      ENDIF
C
C     SAVE ORIGINAL NUMBER OF CHANNELS
C
      NCORIG = NCH
C
C     ASCERTAIN THE NUMBER OF CHANNELS TO BE READ
C
      NCH = 0
      DO I=1,NCORIG
         IF ( ICCURR(I).GT.0 ) NCH = NCH+1
      ENDDO
C
C     CHECK NUMBER OF CHANNELS
C
      IF ( NCH.EQ.0 ) THEN
         IFAIL = 65
         CALL PSRERR ('RDDATS',IFAIL,0,0.,' ')
         RETURN
      ENDIF
C
C     CHECK THAT THE LENGTH OF THE DATA ARRAY HAS BEEN SET
C
      IF ( LENDAT.EQ.0 ) LENDAT = MAXIN*4
C
C     IF THE NUMBER OF CHANNELS HAS CHANGED, RESET THE DATA
C        STORAGE CONTROL VARIABLES
C
      IF ( LENDAT/NCH.NE.LENCHAN ) THEN
         LENCHAN = LENDAT/NCH
         INRD = 0
         INWR = 0
      ENDIF
C
C     CHECK FOR ROOM IN DATA ARRAY
C
      IF ( INWR+NBIN.GT.LENCHAN ) THEN
         IFAIL = 41
         CALL PSRERR ('RDDATS',IFAIL,INWR+NBIN,0.,'Data')
         RETURN
      ENDIF
C
      IF ( DATATYPE.EQ.0 ) THEN
C
C        DATATYPE 0 - SINGLE PULSE - 12-BIT INTEGER DATA BINS
C
         NW = NBIN/2
         DO 10 ICH=0,NCH-1
            IST = NW*(ICORIG(ICH+1)-1)
            INST = LENCHAN*ICH
            DO 20 I=1,NW
               INB(INWR+I*2-1+INST) = JIBITS(INDAT(I+IST), 0,12)
               INB(INWR+I*2  +INST) = JIBITS(INDAT(I+IST),12,12)
   20       CONTINUE
   10    CONTINUE
      ELSEIF ( DATATYPE.EQ.1 ) THEN
C
C        DATATYPE 1 - INTEGRATED   - 24-BIT INTEGER
C
         DO 30 ICH=0,NCH-1
            IST = NBIN*(ICORIG(ICH+1)-1)
            INST = LENCHAN*ICH
            DO 40 I=1,NBIN
               INB(INWR+I+INST) = JIBITS(INDAT(I+IST),0,24)
   40       CONTINUE
   30    CONTINUE
      ELSEIF ( DATATYPE.EQ.2 ) THEN
C
C        DATATYPE 2 - PROCESSED    - 24-BIT FLOATING POINT
C
         CALL PSRERR ( 'RDDATS',39,0,0.,'Reading of datatype 2 is' )
         IFAIL = 39
         NDAT = 0
      ELSEIF ( DATATYPE.EQ.3 ) THEN
C
C        DATATYPE 3 - SPECIAL      - 24-BIT FLOATING POINT
C
         CALL PSRERR ( 'RDDATS',39,0,0.,'Reading of datatype 3 is' )
         IFAIL = 39
         NDAT = 0
      ELSEIF ( DATATYPE.EQ.4 ) THEN
C
C        DATATYPE 4 - SEARCH       -  3-BIT INTEGER
C
         NW = NBIN/8
         DO 50 ICH=0,NCH-1
            IST = NW*(ICORIG(ICH+1)-1)
            ICHST = LENCHAN*ICH
            DO 60 I=1,NW
               K = INWR+I*8+ICHST
               DO 70 J=0,7
                  INB(K-J) = JIBITS(INDAT(I+IST),J*3,3)
   70          CONTINUE
   60       CONTINUE
   50    CONTINUE
      ELSE
         CALL PSRERR ( 'RDDATS',50,DATATYPE,0.0,' ' )
         IFAIL = 50
         NBIN = 0
         RETURN
      ENDIF
C
C UPDATE THE DATA WRITE POINTER
C
      INWR = INWR+NBIN
      RETURN
C
C END OF SUBROUTINE RDDATS
C
      END
*DECK RDASPDATS
C
C *************************************************************
      SUBROUTINE RDASPDATS ( IFAIL )
C *************************************************************
C
C READS DATA FROM THE WORKING SPACE ASSUMING THAT IT CONTAINS
C     A HEADER FOLLOWED BY DATA FROM A PREVIOUS CALL OF RDASPHEAD
C     GIVING ONE SHORT ELEMENT OF THE INPUT ARRAY FOR EACH DATA BIN.
C THE FIRST DATA BIN IS LOADED INTO THE ELEMENT POINTED TO BY INWR
C     AND INWR IS UPDATED AT THE END OF THE READ
C IFAIL=0 IF NO ERROR HAS OCCURRED.
C
C THIS ROUTINE IS INSTALLATION DEPENDENT.
C
C VAX-11 FORTRAN VERSION.
C
      INCLUDE 'PSRLIBDIR:PSRLIB.DEF'
      INCLUDE 'PSRLIBDIR:PSRDAT.DEF'
C
      BYTE INB(MAXIN*4)
      EQUIVALENCE (IN,INB)
      PARAMETER (LENIND=MAXWORK-100)
      INTEGER INDAT(LENIND)
      EQUIVALENCE (WRK(101),INDAT)
C
      IFAIL = 0
C
      IF ( NCH.GT.MAXCHAN ) THEN
         CALL OUTMON (
     &   ' ***** No. of input data channels exceeds array space' )
         CALL OUTMON ( '       Number of channels truncated' )
         NCH = MAXCHAN
      ENDIF
C
C     SAVE ORIGINAL NUMBER OF CHANNELS
C
      NCORIG = NCH
C
C     ASCERTAIN THE NUMBER OF CHANNELS TO BE READ
C
      NCH = 0
      DO I=1,NCORIG
         IF ( ICCURR(I).GT.0 ) NCH = NCH+1
      ENDDO
C
C     CHECK NUMBER OF CHANNELS
C
      IF ( NCH.EQ.0 ) THEN
         IFAIL = 65
         CALL PSRERR ('RDASPDATS',IFAIL,0,0.,' ')
         RETURN
      ENDIF
C
C     CHECK THAT THE LENGTH OF THE DATA ARRAY HAS BEEN SET
C
      IF ( LENDAT.EQ.0 ) LENDAT = MAXIN*4
C
C     IF THE NUMBER OF CHANNELS HAS CHANGED, RESET THE DATA
C        STORAGE CONTROL VARIABLES
C
      IF ( LENDAT/NCH.NE.LENCHAN ) THEN
         LENCHAN = LENDAT/NCH
         INRD = 0
         INWR = 0
      ENDIF
C
C     CHECK FOR ROOM IN DATA ARRAY
C
      IF ( INWR+NBIN.GT.LENCHAN ) THEN
         IFAIL = 41
         CALL PSRERR ('RDASPDATS',IFAIL,INWR+NBIN,0.,'Data')
         RETURN
      ENDIF
C
C
C
         DO 10 ICH=0,NCH-1
            IST = ICORIG(ICH+1) - 1
            INST = LENCHAN*ICH
            DO 20 I=1,NBIN
               INB(INWR+I+INST) = JIBITS(INDAT(I),IST,1)
   20       CONTINUE
   10    CONTINUE
C
C UPDATE THE DATA WRITE POINTER
C
      INWR = INWR+NBIN
      RETURN
C
C END OF SUBROUTINE RDASPDATS
C
      END
